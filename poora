#include "cd.h"
#include "headers.h"

void cd(char *cwd, char *home_dir, char *argument, char *previous_directory)
{
    char return_string[1000];
    if (strlen(argument) == 0)
        strcpy(return_string, home_dir);
    else if (strcmp("-", argument) == 0)
        strcpy(return_string, previous_directory);
    else if (argument[0] == '~')
        strcpy(return_string, home_dir),
            strcat(return_string, argument + 1);
    else
        strcpy(return_string, argument);

    int path_change = chdir(return_string);
    if (path_change == -1)
    {
        perror("Directory change");
    }
}
#include "echo.h"
#include "headers.h"

void echo(char **str, int length)
{
    if (length == 0)
    {
        printf("\n");
        return;
    }
    printf("%s", str[0]);
    for (int x = 1; x < length; x++)
    {
        printf(" %s", str[x]);
    }
    printf("\n");
}
#include "headers.h"
#include "history.h"

void history(int number_of_commands, char *history_file)
{
    FILE *read_file = fopen(history_file, "r");
    char line[1000];
    int command_count = 0;
    char last_command[10000];
    char history_commands[20][1000];

    while (fgets(line, sizeof(line), read_file))
    {
        strcpy(history_commands[command_count], line);
        command_count++;
    }
    fclose(read_file);
    if (command_count < number_of_commands)
    {
        for (int x = 0; x < command_count; x++)
            printf("%s", history_commands[x]);
        return;
    }
    for (int x = command_count - number_of_commands; x < command_count; x++)
        printf("%s", history_commands[x]);
    printf("\n");
}

void add_history(char *command, char *history_file)
{
    if (strlen(command) == 0)
        return;
    FILE *read_file = fopen(history_file, "r");
    char line[1000];
    int command_count = 0;
    char last_command[10000];
    char history_commands[20][1000];
    if (read_file != NULL)
        while (fgets(line, sizeof(line), read_file))
        {
            strcpy(history_commands[command_count], line);
            command_count++;
        }
    if (read_file != NULL)
        fclose(read_file);
    if (strcmp(history_commands[command_count - 1], command) == 0)
    {
        return;
    }

    FILE *clear_file = fopen(history_file, "w");
    fputs("", clear_file);
    fclose(clear_file);

    FILE *append_file = fopen(history_file, "a");
    int starting_val = 0;
    if (command_count == 20)
        starting_val = 1;
    for (int x = starting_val; x < command_count; x++)
    {
        fputs(history_commands[x], append_file);
    }
    if (command_count != 0)
        fputs("\n", append_file);
    fputs(command, append_file);
    fclose(append_file);
}

char *get_nth_history(int n, char *history_file)
{
    FILE *read_file = fopen(history_file, "r");
    char *return_str = calloc(1000, sizeof(char));
    char line[1000];
    int command_count = 0;
    char last_command[10000];
    char history_commands[20][1000];

    while (fgets(line, sizeof(line), read_file))
    {
        strcpy(history_commands[command_count], line);
        command_count++;
    }
    fclose(read_file);
    int a = command_count - n;
    if (a < 0)
        strcpy(return_str, history_commands[0]);
    else
        strcpy(return_str, history_commands[a]);
    if (return_str[strlen(return_str) - 1] == '\n')
        return_str[strlen(return_str) - 1] = '\0';
    return return_str;
}
#include "ls.h"
#include "headers.h"

void print_file_data(char *file_name, char *file_path)
{

    struct stat file_stats;
    int stat_result = stat(file_path, &file_stats);
    if (stat_result == -1)
    {
        char err_buf[1100];
        sprintf(err_buf, "Error reading %s", file_name);
        perror(err_buf);
        return;
    }
    if (S_ISDIR(file_stats.st_mode))
        printf("d");
    else
        printf("-");
    if (file_stats.st_mode & S_IRUSR)
        printf("r");
    else
        printf("-");
    if (file_stats.st_mode & S_IWUSR)
        printf("w");
    else
        printf("-");
    if (file_stats.st_mode & S_IXUSR)
        printf("x");
    else
        printf("-");
    if (file_stats.st_mode & S_IRGRP)
        printf("r");
    else
        printf("-");
    if (file_stats.st_mode & S_IWGRP)
        printf("w");
    else
        printf("-");
    if (file_stats.st_mode & S_IXGRP)
        printf("x");
    else
        printf("-");
    if (file_stats.st_mode & S_IROTH)
        printf("r");
    else
        printf("-");
    if (file_stats.st_mode & S_IWOTH)
        printf("w");
    else
        printf("-");
    if (file_stats.st_mode & S_IXOTH)
        printf("x");
    else
        printf("-");
    printf(" ");
    printf(" %3d", (int)file_stats.st_nlink);

    struct passwd *pw = getpwuid(file_stats.st_uid);
    if (pw == NULL)
    {
        char err_buf[1100];
        sprintf(err_buf, "\rError getting owner name of %s\t\t\t", file_name);
        perror(err_buf);
        return;
    }
    printf("  %10s", pw->pw_name);
    struct group *grp = getgrgid(file_stats.st_gid);
    if (grp == NULL)
    {
        char err_buf[1100];
        sprintf(err_buf, "\rError getting owner name of %s\t\t\t", file_name);
        perror(err_buf);
        return;
    }
    printf("  %10s", grp->gr_name);
    printf(" %10d", (int)file_stats.st_size);
    struct tm *file_time = localtime(&file_stats.st_mtim.tv_sec);
    int file_date = file_time->tm_mday;
    int file_month = file_time->tm_mon;
    int file_year = 1900 + file_time->tm_year;
    int file_hour = file_time->tm_hour;
    int file_min = file_time->tm_min;
    int file_sec = file_time->tm_sec;

    time_t raw_curr_time;
    time(&raw_curr_time);
    struct tm *curr_time_info = localtime(&raw_curr_time);

    char month_array[12][20] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
    printf(" %s", month_array[file_month]);
    printf(" %2d", file_date);
    if (curr_time_info->tm_year != file_year)
    {
        printf(" %2d:%2d", file_hour, file_min);
    }
    else if (curr_time_info->tm_mon - file_month > 6)
        printf(" %2d:%2d", file_hour, file_min);
    else if ((curr_time_info->tm_mon - file_month == 6) && (curr_time_info->tm_mday > file_date))
        printf(" %2d:%2d", file_hour, file_min);
    else
        printf(" %4d", file_year);

    printf(" %d", 1900 + file_time->tm_year);
    printf(" %s", file_name);
    printf("\n");
}

void ls(char *home_dir, bool a_flag, bool l_flag, char **argument_list, int arg_length)
{
    char *argument;
    for (int y = 0; y < arg_length; y++)
    {
        bool free_flag = false;
        argument = argument_list[y];
        if (strlen(argument) == 0)
            argument[0] = '.';
        if (argument[0] == '~')
        {
            char *new_argument = calloc(1000, sizeof(char));
            strcpy(new_argument, home_dir);
            strcat(new_argument, argument + 1);
            argument = new_argument;
            free_flag = true;
        }

        //Testing if a file or directory
        struct stat stats;
        int stat_return = stat(argument, &stats);
        if (stat_return != 0)
        {
            perror("Cannot open directory or file");
            continue;
        }

        //Code for a directory
        if (S_ISDIR(stats.st_mode))
        {
            if (arg_length > 1)
            {
                if (y > 0)
                    printf("\n");
                printf("%s:\n", argument);
            }
            struct dirent *next_file;
            DIR *dire = opendir(argument);

            if (dire == NULL)
            {
                perror("Couldnt open directory");
            }

            char *file_name = calloc(1000, sizeof(char));
            if (!dire)
            {
                perror("Opening Directory");
                continue;
            }
            if (l_flag)
            {
                int total_siz = 0;
                next_file = readdir(dire);
                while ((next_file != NULL))
                {
                    strcpy(file_name, next_file->d_name);
                    if (!a_flag && file_name[0] == '.')
                    {
                        next_file = readdir(dire);
                        continue;
                    }

                    if (!l_flag)
                    {
                        next_file = readdir(dire);
                        continue;
                    }
                    char file_path[10000];
                    strcpy(file_path, argument);
                    strcat(file_path, "/");
                    strcat(file_path, file_name);
                    struct stat file_stats;
                    int stat_result = stat(file_path, &file_stats);
                    if (stat_result == -1)
                    {
                        char err_buf[1100];
                        sprintf(err_buf, "Error reading %s", file_name);
                        perror(err_buf);
                        return;
                    }
                    total_siz += file_stats.st_blocks;
                    next_file = readdir(dire);
                }
                printf("total %d\n", total_siz / 2);
            }

            dire = opendir(argument);

            if (dire == NULL)
            {
                perror("Couldnt open directory");
            }

            if (!dire)
            {
                perror("Opening Directory");
                continue;
            }

            next_file = readdir(dire);
            while ((next_file != NULL))
            {
                strcpy(file_name, next_file->d_name);
                if (!a_flag && file_name[0] == '.')
                {
                    next_file = readdir(dire);
                    continue;
                }

                if (!l_flag)
                {
                    printf("%s\n", next_file->d_name);
                    next_file = readdir(dire);
                    continue;
                }
                char file_path[10000];
                strcpy(file_path, argument);
                strcat(file_path, "/");
                strcat(file_path, file_name);
                print_file_data(file_name, file_path);
                next_file = readdir(dire);
            }
            if (free_flag)
                free(argument);
            free(file_name);
            continue;
        }

        //Code for a file
        int length = strlen(argument);
        int break_index = 0;
        for (int x = 0; x < length; x++)
            if (argument[x] == '/')
                break_index = x + 1;

        char *file_name = (char *)calloc(1000, sizeof(char));
        strcpy(file_name, argument + break_index);
        if (l_flag)
            print_file_data(file_name, argument);
        else
            printf("%s\n", file_name);

        free(file_name);
        if (free_flag)
            free(argument);
        continue;
    }
}
#include "prompt.h"
#include "headers.h"
#include "cd.h"
#include "echo.h"
#include "pwd.h"
#include "ls.h"
#include "process.h"
#include "pinfo.h"
#include "history.h"

char home_dir[10000], pwd[10000];
char previous_directory[10000];
char temp_directory[10000];

void ignoresignal(int signal)
{
    return;
}

void die(const char *s)
{
    perror(s);
    exit(1);
}

struct termios orig_termios;

void disableRawMode()
{
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios) == -1)
        die("tcsetattr");
}

/**
 * Enable row mode for the terminal
 * The ECHO feature causes each key you type to be printed to the terminal, so you can see what you’re typing.
 * Terminal attributes can be read into a termios struct by tcgetattr().
 * After modifying them, you can then apply them to the terminal using tcsetattr().
 * The TCSAFLUSH argument specifies when to apply the change: in this case, it waits for all pending output to be written to the terminal, and also discards any input that hasn’t been read.
 * The c_lflag field is for “local flags”
 */
void enableRawMode()
{
    if (tcgetattr(STDIN_FILENO, &orig_termios) == -1)
        die("tcgetattr");
    atexit(disableRawMode);
    struct termios raw = orig_termios;
    raw.c_lflag &= ~(ICANON | ECHO);
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1)
        die("tcsetattr");
}

/**
 * stdout and stdin are buffered we disable buffering on that
 * After entering in raw mode we read characters one by one
 * Up arrow keys and down arrow keys are represented by 3 byte escape codes
 * starting with ascii number 27 i.e. ESC key
 * This way we interpret arrow keys
 * Tabs are usually handled by the term, but here we are simulating tabs for the sake of simplicity
 * Backspace move the cursor one control character to the left
 * @return
 */

void execute_command(char *command, char **args, int i, char *history_file)
{
    if (strcmp(command, "echo") == 0)
    {
        echo(args, i);
    }

    else if (strcmp(command, "pwd") == 0)
    {
        get_pwd(pwd);
    }

    else if (strcmp(command, "ls") == 0)
    {
        char *ls_arguments[100];
        int ls_arg_count = 0;
        bool a_flag = false, l_flag = false, is_flag = false;
        for (int x = 0; x < i; x++)
        {
            is_flag = false;
            char *ag = args[x];
            if (ag[0] == '-')
            {
                is_flag = true;
                int ag_len = strlen(ag);
                for (int y = 1; y < ag_len; y++)
                {
                    if (ag[y] == 'a')
                        a_flag = true;
                    else if (ag[y] == 'l')
                        l_flag = true;
                    else
                        a_flag = false, l_flag = false, is_flag = false;
                }
            }
            if (!is_flag)
            {
                ls_arguments[ls_arg_count] = calloc(strlen(args[x]) + 10, sizeof(char));
                strcpy(ls_arguments[ls_arg_count], args[x]);
                ls_arg_count++;
            }
        }
        if (ls_arg_count == 0)
        {
            ls_arguments[0] = calloc(10, sizeof(char));
            ls_arg_count++;
            strcpy(ls_arguments[0], ".");
        }
        ls(home_dir, a_flag, l_flag, ls_arguments, ls_arg_count);
        for (int y = 0; y < ls_arg_count; y++)
            free(ls_arguments[y]);
    }

    else if (strcmp(command, "cd") == 0)
    {
        char *cd_argument;
        if (i == 0)
        {
            cd_argument = "";
        }
        else if (i == 1)
            cd_argument = args[0];
        else
        {
            printf("Error: Invalid arguments given for cd\n");
            return;
        }
        strcpy(temp_directory, pwd);
        cd(pwd, home_dir, cd_argument, previous_directory);
        strcpy(previous_directory, temp_directory);
    }

    else if (strcmp(command, "pinfo") == 0)
    {
        pid_t pid;
        if (i == 0)
        {
            pid = getpid();
        }
        else
            pid = atoi(args[0]);
        pinfo(pid, home_dir);
    }

    else if (strcmp(command, "repeat") == 0)
    {
        char *pass_command[100];
        int command_count = atoi(args[0]);
        for (int x = 0; x < command_count; x++)
        {
            for (int y = 2; y < i; y++)
            {
                pass_command[y - 2] = calloc(strlen(args[y]), sizeof(char));
                strcpy(pass_command[y - 2], args[y]);
            }
            int bc = i - 2;
            if (i - 2 < 0)
                bc = 0;
            execute_command(args[1], pass_command, bc, history_file);
            for (int y = 2; y < i; y++)
            {
                free(pass_command[y - 2]);
            }
        }
    }

    else if (strcmp(command, "history") == 0)
    {
        // add_history("10");
        if (i == 0)
            history(10, history_file);
        else
            history(atoi(args[0]), history_file);
    }

    else
    {
        bool backround_process = false;
        if (i > 0)
        {
            int arg_length = strlen(args[i - 1]);
            if (args[i - 1][arg_length - 1] == '&')
            {
                args[i - 1][arg_length - 1] = '\0';
                backround_process = true;
                if (arg_length == 1)
                {
                    args[i - 1] = NULL;
                    i--;
                }
            }
        }
        int cmd_len = strlen(command);
        if (command[cmd_len - 1] == '&')
            command[cmd_len - 1] = '\0', backround_process = true;
        execute_process(command, i, args, backround_process);
    }
}

int main()
{
    proc_no = 0;

    getcwd(home_dir, 10000);
    strcpy(previous_directory, home_dir);
    if (errno == ERANGE)
    {
        perror("Prompt details");
    }
    signal(SIGCHLD, finish_proc);
    char *history_file = calloc(1000, sizeof(char));
    strcpy(history_file, home_dir);
    strcat(history_file, "/history.txt");

    char *all_commands = calloc(100, sizeof(char));
    char c;
    int prev_command_no = 0;

    while (1)
    {
        prev_command_no = 0;
        getcwd(pwd, 10000);
        prompt(pwd, home_dir);
        signal(SIGINT, ignoresignal);
        signal(SIGTSTP, ignoresignal);

        setbuf(stdout, NULL);
        enableRawMode();
        memset(all_commands, '\0', 100);
        int pt = 0;
        while (read(STDIN_FILENO, &c, 1) == 1)
        {
            if (iscntrl(c))
            {
                if (c == 10)
                    break;
                else if (c == 27)
                {
                    char buf[3];
                    buf[2] = 0;
                    if (read(STDIN_FILENO, buf, 2) == 2)
                    { // length of escape code
                        if (buf[1] == 'A')
                        {
                            printf("\r");
                            for (int x = 0; x < 100; x++)
                                printf(" ");
                            printf("\r");
                            prompt(pwd, home_dir);
                            prev_command_no++;
                            char *history_command = get_nth_history(prev_command_no, history_file);
                            pt = strlen(history_command);
                            strcpy(all_commands, history_command);
                            all_commands[pt] = '\0';
                            printf("%s", history_command);
                            free(history_command);
                        }
                    }
                }
                else if (c == 127)
                { // backspace
                    if (pt > 0)
                    {
                        if (all_commands[pt - 1] == 9)
                        {
                            for (int i = 0; i < 7; i++)
                            {
                                printf("\b");
                            }
                        }
                        all_commands[--pt] = '\0';
                        printf("\b \b");
                    }
                }
                else if (c == 9)
                { // TAB character
                    all_commands[pt++] = c;
                    for (int i = 0; i < 8; i++)
                    { // TABS should be 8 spaces
                        printf(" ");
                    }
                }
                else if (c == 4)
                {
                    exit(0);
                }
                else
                {
                    printf("%d\n", c);
                }
            }
            else
            {
                all_commands[pt++] = c;
                printf("%c", c);
            }
        }
        disableRawMode();
        all_commands[pt] = '\0';
        printf("\n");

        char *each_command;
        char *savepointer1, *savepointer2;
        add_history(all_commands, history_file);

        each_command = strtok_r(all_commands, ";", &savepointer1);

        while (each_command != NULL)
        {
            char *token = strtok_r(each_command, " \t", &savepointer2);
            char *command = token;
            char *args[100];
            int i = 0;
            token = strtok_r(NULL, " \t", &savepointer2);
            while (token != NULL)
            {
                args[i] = token;
                i++;
                token = strtok_r(NULL, " \t", &savepointer2);
            }

            if (strcmp(command, "exit") == 0)
            {
                return 0;
            }

            execute_command(command, args, i, history_file);

            each_command = strtok_r(NULL, ";", &savepointer1);
        }
        fflush(stdin);

        // TAKE INPUT HERE
        // free(all_commands);
    }
}
#include "headers.h"
#include "pinfo.h"
#include "prompt.h"

bool startswith(char *str1, char *str2)
{
    int len1 = strlen(str1), len2 = strlen(str2);
    if (len1 < len2)
        return false;
    for (int x = 0; x < len2; x++)
    {
        if (str1[x] != str2[x])
            return false;
    }
    return true;
}

void pinfo(pid_t pid, char *home_dir)
{
    FILE *file_ptr;
    char *line = NULL;

    char *proc_name = calloc(10000, sizeof(char));
    char *proc_file = calloc(10000, sizeof(char));
    sprintf(proc_name, "/proc/%d", pid);
    strcpy(proc_file, proc_name);
    strcat(proc_file, "/stat");
    char a[1000], b[1000], c[1000];
    size_t len = 0;
    ssize_t read;

    printf("pid -- %d\n", pid);
    file_ptr = fopen(proc_file, "r");
    if (file_ptr == NULL)
    {
        perror("Invalid process");
        return;
    }
    fscanf(file_ptr, "%s %s %s", a, b, c);
    printf("Process Status -- %s", c);
    if (getpgid(pid) == tcgetpgrp(STDIN_FILENO))
    {
        printf("+");
    }
    printf("\n");
    strcpy(proc_file, proc_name);
    strcat(proc_file, "/status");
    fclose(file_ptr);
    file_ptr = fopen(proc_file, "r");

    while ((read = getline(&line, &len, file_ptr)) != -1)
    {
        if (startswith(line, "VmSize:"))
        {
            char *temp_string = calloc(100, sizeof(char));
            strcpy(temp_string, line + 8);
            temp_string[strlen(temp_string) - 1] = '\0';
            printf("memory -- %s {Virtual Memory}\n", temp_string);
            free(temp_string);
        }
    }

    strcpy(proc_file, proc_name);
    strcat(proc_file, "/exe");
    char *executable_path = calloc(1000, sizeof(char));
    if (readlink(proc_file, executable_path, 1000) < 0)
    {
        perror("Error getting exec path");
        return;
    }
    char *final_exec_path = process_path(executable_path, home_dir);
    printf("Executable Path -- %s\n", final_exec_path);
    free(executable_path);
    free(final_exec_path);
    fclose(file_ptr);
    if (line)
        free(line);

    free(proc_name);
    free(proc_file);
}
#include "headers.h"
#include "process.h"

void execute_process(char *command, int i, char **args, bool backround_process)
{
    fflush(stdin);
    char *exec_arguments[i + 2];
    exec_arguments[0] = calloc(strlen(command) + 2, sizeof(char));
    strcpy(exec_arguments[0], command);
    for (int x = 0; x < i; x++)
    {
        exec_arguments[x + 1] = calloc(100, sizeof(char));
        printf("%s", args[x]);
        strcpy(exec_arguments[x + 1], args[x]);
    }
    exec_arguments[i + 1] = (char *)NULL;

    int pid = fork();
    if (pid < 0)
    {
        perror("Error running process");
        return;
    }
    else if (pid == 0)
    {
        if (backround_process)
            setpgid(0, 0);
        int exec_return = execvp(command, exec_arguments);
        if (exec_return < 0)
        {
            perror("Error in process");
            exit(0);
        }
    }
    else
    {
        if (backround_process)
        {
            bg_jobs[proc_no].agrv = calloc(i, sizeof(char *));
            for (int y = 0; y < i + 1; y++)
            {
                bg_jobs[proc_no].agrv[y] = calloc(strlen(exec_arguments[y]) + 10, sizeof(char));
                strcpy(bg_jobs[proc_no].agrv[y], exec_arguments[y]);
            }
            bg_jobs[proc_no].agrv[i + 2] = NULL;
            bg_jobs[proc_no].pid = pid;
            bg_jobs[proc_no].number_of_args = i + 1;
            proc_no++;
            printf("%d\n", pid);
        }
        else
        {
            int status;
            pid_t wtpid = waitpid(pid, &status, WUNTRACED);
            printf("\n");
        }
    }
    for (int y = 0; y < i + 1; y++)
        free(exec_arguments[y]);
    return;
}

void finish_proc()
{
    int status;
    bool flag = false;
    char **argv;
    char *pname;
    pid_t pid;
    int number_of_remove_args = 0;
    int job_index = 0;
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
    {
        for (int x = 0; x < proc_no; x++)
        {
            if (bg_jobs[x].pid == pid)
            {
                flag = true;
                argv = bg_jobs[x].agrv;
                number_of_remove_args = bg_jobs[x].number_of_args;

                for (int y = x; y < proc_no - 1; y++)
                {
                    bg_jobs[y].agrv = bg_jobs[y + 1].agrv;
                    bg_jobs[y].pid = bg_jobs[y + 1].pid;
                }
                proc_no--;
                int cur_rem = 0;
                break;
            }
        }

        if (!flag)
            continue;
        // for (int x = 0; x < 10; x++)
        //     printf("%s", argv[x]);
        if (!WEXITSTATUS(status) && WIFEXITED(status))
            fprintf(stderr, "%s with PID %d exited normally.\n", argv[0], pid);
        else
            fprintf(stderr, "%s with PID %d exited abnormally.\n", argv[0], pid);

        restart_loop = true;
        for (int y = 0; y < number_of_remove_args; y++)
            free(argv[y]);
        free(argv);
        fflush(stdin);
        fflush(stdout);
    }
}
#include "prompt.h"
#include "headers.h"

char *
process_path(char *pwd, char *home_dir)
{
    // printf("PROMPT %s %s\n", pwd, home_dir);
    char temp_path[10000];
    char *processed_path = calloc(10000, sizeof(char));
    long long home_dir_length = strlen(home_dir);
    long long pwd_length = strlen(pwd);

    if (pwd_length < home_dir_length)
    {
        strcpy(processed_path, pwd);
        return processed_path;
    }

    strncpy(temp_path, pwd, home_dir_length);
    if (strcmp(temp_path, home_dir) == 0)
    {
        strcat(processed_path, "~");
        strcat(processed_path, pwd + home_dir_length);
        char *return_string = calloc((strlen(processed_path) + 5), sizeof(char));
        strcpy(return_string, processed_path);
        free(processed_path);
        return return_string;
    }
    strcpy(processed_path, pwd);
    return processed_path;
}
void prompt(char *pwd, char *home_dir)
{
    int userid = getuid();
    struct passwd *userstruct = getpwuid(userid);

    char *path_name = process_path(pwd, home_dir);
    if (userstruct == NULL)
    {
        perror(("Error in pwid"));
    }
    char *username = userstruct->pw_name;
    char hostname[10000];
    int hostname_status = gethostname(hostname, 10000);
    if (hostname_status == -1)
    {
        perror("Hostname error");
    }
    printf("<%s@%s:%s>", username, hostname, path_name);
    free(path_name);
}
#include "pwd.h"
#include "headers.h"

void get_pwd(char *cwd)
{
    printf("%s\n", cwd);
}